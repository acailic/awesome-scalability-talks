[
  {
    "id": "react-hooks-explained",
    "title": "React Hooks Explained in 15 Minutes",
    "description": "A quick and comprehensive overview of React Hooks and how they work.",
    "videoUrl": "https://www.youtube.com/watch?v=example1",
    "thumbnailUrl": "/images/thumbnails/react-hooks.jpg",
    "tags": ["React", "Hooks", "Beginners"],
    "date": "2023-09-15",
    "content": "# React Hooks Explained\n\nReact Hooks are functions that let you 'hook into' React state and lifecycle features from function components. They were introduced in React 16.8 and have changed how we write React components.\n\n## useState\n\nThe useState hook lets you add state to functional components. It takes an initial state value and returns an array with the current state value and a function to update it.\n\n```jsx\nconst [count, setCount] = useState(0);\n```\n\n## useEffect\n\nThe useEffect hook lets you perform side effects in function components. It serves the same purpose as componentDidMount, componentDidUpdate, and componentWillUnmount in React classes.\n\n```jsx\nuseEffect(() => {\n  document.title = `You clicked ${count} times`;\n}, [count]); // Only re-run the effect if count changes\n```\n\n## Key Takeaways\n\n- Hooks let you use state and other React features without classes\n- They promote reusability through custom hooks\n- They help organize related code together instead of splitting by lifecycle methods"
  },
  {
    "id": "react-performance",
    "title": "10 Performance Tips for React Applications",
    "description": "Learn how to optimize your React apps for better performance.",
    "videoUrl": "https://www.youtube.com/watch?v=example2",
    "thumbnailUrl": "/images/thumbnails/react-performance.jpg",
    "tags": ["React", "Performance", "Optimization"],
    "date": "2023-10-05",
    "content": "# React Performance Optimization Tips\n\nOptimizing React applications is essential for providing a smooth user experience. Here are key strategies discussed in the video:\n\n## 1. Use React.memo for Component Memoization\n\nWrap components with React.memo to prevent unnecessary re-renders when props haven't changed.\n\n```jsx\nconst MyComponent = React.memo(function MyComponent(props) {\n  /* render using props */\n});\n```\n\n## 2. Optimize State Structure\n\nKeep state as minimal and flat as possible. Split complex state into smaller pieces.\n\n## 3. Use the useCallback Hook\n\nMemoize callback functions to prevent unnecessary re-renders of child components.\n\n```jsx\nconst memoizedCallback = useCallback(() => {\n  doSomething(a, b);\n}, [a, b]);\n```\n\n## 4. Implement Code Splitting with React.lazy\n\nOnly load components when needed to reduce initial bundle size.\n\n```jsx\nconst LazyComponent = React.lazy(() => import('./LazyComponent'));\n```\n\n## 5. Avoid Anonymous Functions in Renders\n\nDefine functions outside the render method to prevent new function creation on each render."
  }
]
